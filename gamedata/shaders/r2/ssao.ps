#ifndef SSAO_1231242112
#define SSAO_1231242112
#include "common.h"

#define SSAO_RADIUS 0.8
uniform sampler2D jitter0;

float4 ssao_params;
float4 pos_decompression_params;

float3 uv_to_eye(float2 uv, float eye_z)
{
    uv = uv * float2(2.0, 2.0) - float2(1.0, 1.0);
    return float3(uv * pos_decompression_params.xy * eye_z, eye_z);
}

/* 
	SSAO Нагло украдено у Sir Lancevrot (с его разрешения)
*/

float3 GetViewPos(float2 uv)
{
	float depth = 0.0;
	#ifndef SSAO_OPT_DATA
		depth = tex2Dlod (s_position, float4(uv, 0, 0)).z;
	#else
		depth = tex2Dlod (s_half_depth, float4(uv, 0, 0));
	#endif
    return uv_to_eye(uv, depth);
}

float doPBAO(float2 uv, float3 pos, float3 n, float invRad, float bias, float selfOcc)
{
	float3 p = GetViewPos(uv);
	float3 dist	= p - pos;
	float3 v = normalize(dist);
	float atten	= length(dist) * invRad;
	return max(-selfOcc, dot(n, v) - bias) * (1.0f / (atten * atten + 1.0f));
}

float calc_ssao(float3 pos, float3 normal, float2 tc0, float2 tcJ)
{
	// define kernel
	float n = 0.0f;
	const float step = 0.875f;
	const float fScale = 0.025f; 

	const float DEG2RAD = 0.017453292519943295769236907685f;
	const float pi = 3.141592653589793238462643383279f;
	const float twopi = 6.283185307179586476925286766559f;
	const float invPi = 0.318309886183790671537767526745f;
	const float  inv2 = 0.5f;
	const float  inv5_3 = 0.188679245283f;
	const float  inv8 = 0.125f;
	const float  inv16 = 0.0625f;
	const float  selfOcc = 0.0f; // range: 0.0f to 1.0f
	const float2 focalLen = 1.0f / pos_decompression_params.xy;

	const float3 arrKernel[8] =
	{
		normalize(float3( 1.0,  1.0,  1.0 )) * fScale * (n += step),
		normalize(float3(-1.0, -1.0, -1.0 )) * fScale * (n += step),
		normalize(float3(-1.0, -1.0,  1.0 )) * fScale * (n += step),
		normalize(float3(-1.0,  1.0, -1.0 )) * fScale * (n += step),
		normalize(float3(-1.0,  1.0,  1.0 )) * fScale * (n += step),
		normalize(float3( 1.0, -1.0, -1.0 )) * fScale * (n += step),
		normalize(float3( 1.0, -1.0,  1.0 )) * fScale * (n += step),
		normalize(float3( 1.0,  1.0, -1.0 )) * fScale * (n += step),
	};
	
	// create random rot matrix
	#ifndef USE_SSAO_BLUR
		#if defined(SSAO_OPT_DATA) && SSAO_OPT_DATA == 2
			float2 tc1 = (tc0 * screen_res.xy % 4) * 0.0078125f;
		#else
			float2 tc1 = tc0 * screen_res.xy * 0.015625f;
		#endif
	#else
		float2 tc1 = (tc0 * screen_res.xy % 4) * 0.015625f;
	#endif
	
	float3 rotSample = tex2D(jitter0, tc1);
	rotSample = normalize(rotSample);
	normal = normalize(normal);

	pos *= 0.99f;
	// calculate angle bias
	float bias = 0.0;
	
	// calculate contrast
	float contrast	=  inv16 / (1.0f - saturate(bias));

	// calculate radius
	float radius = SSAO_RADIUS * saturate(pos.z * inv5_3) * (1.0f + pos.z * inv8);
	float invRad = 1.0f / radius;
	float2 radius2D	= radius * focalLen / pos.z;
	float ao = 0.0f;

	// calculate ao
//	[unroll(8)]
	for ( int i = 0; i < 8; i++ ) {
		float2 deltaUV = reflect(arrKernel[i], rotSample) * radius2D;		
		ao += doPBAO( tc0 + deltaUV, pos, normal, invRad, bias, selfOcc);
		ao += doPBAO( tc0 + deltaUV * inv2, pos, normal, invRad, bias, selfOcc);
	}

	ao = 1.0 - (ao * contrast + selfOcc);
	return ao * ao * ao;
}
#endif